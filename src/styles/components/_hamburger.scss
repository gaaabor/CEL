.toggle-btn {
   position: absolute;
   top: 30px;
   left: 330px;
}

.toggle-btn:focus {outline:0;}
//  @media only screen and (max-width: 1000px) {
//     display: block;
//  }

@charset "UTF-8";
/*!
 * Hamburgers
 * @description Tasty CSS-animated hamburgers
 * @author Jonathan Suh @jonsuh
 * @site https://jonsuh.com/hamburgers
 * @link https://github.com/jonsuh/hamburgers
 */

// Settings
// ==================================================
$hamburger-padding-x                       : 1.5rem !default;
$hamburger-padding-y                       : 1.5rem !default;
$hamburger-layer-width                     : 4rem !default;
$hamburger-layer-height                    : .4rem !default;
$hamburger-layer-spacing                   : .6rem !default;
$hamburger-layer-color                     : $color-white !default;
$hamburger-layer-border-radius             : 4px !default;
$hamburger-hover-opacity                   : 1 !default;
$hamburger-hover-transition-duration       : 0.15s !default;
$hamburger-hover-transition-timing-function: linear !default;

// To use CSS filters as the hover effect instead of opacity,
// set $hamburger-hover-use-filter as true and
// change the value of $hamburger-hover-filter accordingly.
$hamburger-hover-use-filter: false !default;
$hamburger-hover-filter    : opacity(50%) !default;

// Types (Remove or comment out what you donâ€™t need)
// ==================================================
$hamburger-types: (
  arrowalt
) !default;

// Base Hamburger (We need this)
// ==================================================
@if index($hamburger-types, arrowalt) {
   /*
    * Arrow Alt
    */
   .hamburger--arrowalt {
     .hamburger-inner {
       &::before {
         transition: top 0.1s 0.1s ease,
                     transform 0.1s cubic-bezier(0.165, 0.84, 0.44, 1);
       }
 
       &::after {
         transition: bottom 0.1s 0.1s ease,
                     transform 0.1s cubic-bezier(0.165, 0.84, 0.44, 1);
       }
     }
 
     &.is-active {
       .hamburger-inner {
         &::before {
           top: 0;
           transform: translate3d($hamburger-layer-width * -0.2, $hamburger-layer-width * -0.25, 0) rotate(-45deg) scale(0.7, 1);
           transition: top 0.1s ease,
                       transform 0.1s 0.1s cubic-bezier(0.895, 0.03, 0.685, 0.22);
         }
 
         &::after {
           bottom: 0;
           transform: translate3d($hamburger-layer-width * -0.2, $hamburger-layer-width * 0.25, 0) rotate(45deg) scale(0.7, 1);
           transition: bottom 0.1s ease,
                       transform 0.1s 0.1s cubic-bezier(0.895, 0.03, 0.685, 0.22);
         }
       }
     }
   }
 }
// Hamburger
// ==================================================
.hamburger {
    display: none;
    background-color: $color-primary;

   @media only screen and (max-width: 1000px) {
      display: inline-block;
   }

   padding: $hamburger-padding-y $hamburger-padding-x;
   cursor: pointer;
 
   transition-property: opacity, filter;
   transition-duration: $hamburger-hover-transition-duration;
   transition-timing-function: $hamburger-hover-transition-timing-function;
 
   // Normalize (<button>)
   font: inherit;
   color: inherit;
   text-transform: none;
  //  background-color: transparent;
   border: 0;
   margin: 0;
   overflow: visible;
 
   &:hover {
     @if $hamburger-hover-use-filter == true {
       filter: $hamburger-hover-filter;
     }
     @else {
       opacity: $hamburger-hover-opacity;
     }
   }
 }
 
 .hamburger-box {
   width: $hamburger-layer-width;
   height: $hamburger-layer-height * 3 + $hamburger-layer-spacing * 2;
   display: inline-block;
   position: relative;
   transform: translateY(2px);
 }
 
 .hamburger-inner {
   display: block;
   top: 50%;
   margin-top: $hamburger-layer-height / -2;
 
   &,
   &::before,
   &::after {
     width: $hamburger-layer-width;
     height: $hamburger-layer-height;
     background-color: $hamburger-layer-color;
     border-radius: $hamburger-layer-border-radius;
     position: absolute;
     transition-property: transform;
     transition-duration: 0.15s;
     transition-timing-function: ease;
   }
 
   &::before,
   &::after {
     content: "";
     display: block;
   }
 
   &::before {
     top: ($hamburger-layer-spacing + $hamburger-layer-height) * -1;
   }
 
   &::after {
     bottom: ($hamburger-layer-spacing + $hamburger-layer-height) * -1;
   }
 }
 
// ==================================================
// Cooking up additional types:
//
// The Sass for each hamburger type should be nested
// inside an @if directive to check whether or not
// it exists in $hamburger-types so only the CSS for
// included types are generated.
//
// e.g. hamburgers/types/_new-type.scss
//
// @if index($hamburger-types, new-type) {
//   .hamburger--new-type {
//     ...
//   }
// }
